# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CouchdbImporter
                                 A QGIS plugin
 This plugin allows importing vector data from the couchdb database.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-01-30
        git sha              : $Format:%H$
        copyright            : (C) 2020 by MaximeGavens/Geomatys
        email                : contact@geomatys.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QVariant
from qgis.PyQt.QtGui import QIcon, QStandardItem, QStandardItemModel
from qgis.PyQt.QtWidgets import QAction, QDialog, QSizePolicy, QGridLayout, QDialogButtonBox

from qgis.gui import QgsMessageBar
from qgis.core import QgsFeature, QgsGeometry, QgsVectorLayer, QgsProject, QgsField, QgsPoint, QgsLineString, QgsLineSymbol, QgsMarkerSymbol, Qgis

import json

# Initialize Qt resources from file resources.py
from .resources import *

from .couchdb_importer_dialog import CouchdbImporterDialog
import os.path

from .couchdb_connector import CouchdbConnector, CouchdbConnectorException
from .utils import Utils


class CouchdbImporter:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'CouchdbImporter_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Couchdb Importer')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # class object
        self.currentPositionableClass = ""

        # preload result
        self.total = {}

        # positionable
        self.positionableSelected = []

        # principal data
        self.data = {}
        self.complete_data_with_configuration()

        # length parameter used to determine if layer is a point
        self.lengthParameter = 500

        # projection choice
        self.projection = "projeté"

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('CouchdbImporter', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/couchdb_importer/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Import Couchdb Data'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'&Couchdb Importer'),
                action)
            self.iface.removeToolBarIcon(action)

    """
    /****************************************************************
    * Methods used to read / write / update 'configuration.json' file
    ****************************************************************/  
    """

    def complete_data_with_configuration(self):
        __location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))
        with open(os.path.join(__location__, 'configuration.json')) as inFile:
            preference = json.load(inFile)
            for className in preference:
                self.data[className] = {
                    "selected": True,
                    "ids": "all",
                    "attributes": preference[className]["attributes"],
                    "style": preference[className]["style"],
                    "crs": preference[className]["crs"]
                }

    def write_configuration(self):
        __location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))
        with open(os.path.join(__location__, 'configuration.json'), 'w') as outFile:
            preference = {}
            for className in self.data:
                preference[className] = {}
                preference[className]["attributes"] = self.data[className]["attributes"]
                preference[className]["style"] = self.data[className]["style"]
                preference[className]["crs"] = self.data[className]["crs"]
            json.dump(preference, outFile)



    """
    /****************************************************************
    * Methods used to modify the principal data structure.
    * Data structure represents the user's preferences for import of
    * layers.
    ****************************************************************/  
    """

    def update_positionable_selected(self):
        try:
            server = self.connector.getConnection()
            db = server[self.dlg.database.currentText()]
            self.positionableSelected.clear()
            for className in self.data:
                if self.data[className]["selected"]:
                    attributes = Utils.build_list_from_preference(self.data[className]["attributes"])
                    if self.data[className]["ids"] == "all":
                        query = Utils.build_query(className, attributes)
                    else:
                        ids = Utils.build_list_from_preference(self.data[className]["ids"])
                        query = Utils.build_query(className, attributes, ids)
                    result = db.find(query)
                    self.positionableSelected.extend(result)
        except ConnectionRefusedError:
            widget = self.iface.messageBar().createMessage("CouchdbConnectorException", "Impossible de se connecter, vérifier l'url ou l'ouverture de la base.")
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=5)
            raise CouchdbConnectorException("Impossible de se connecter à la base")

    def complete_data_with_ids(self):
        for className in self.data:
            self.data[className]["ids"] = {}
        for pos in self.positionableSelected:
            className = pos["@class"].split("fr.sirs.core.model.")[1]
            self.data[className]["ids"][pos["_id"]] = True

    """
    /****************************************************************
    * Method used to set modify UI access field.
    ****************************************************************/  
    """

    def set_ui_access_connection(self):
        # enable connection param
        self.dlg.url.setEnabled(True)
        self.dlg.login.setEnabled(True)
        self.dlg.password.setEnabled(True)
        self.dlg.loginButton.setEnabled(True)
        self.dlg.resetConnectionButton.setEnabled(True)
        self.dlg.selectAllPositionableClass.setCheckable(False)
        self.dlg.selectAllAttribute.setCheckable(False)
        self.dlg.addLayers.setEnabled(False)
        self.dlg.updateLayers.setEnabled(False)
        # disable all other
        self.dlg.database.setEnabled(False)
        self.dlg.database_2.setEnabled(False)
        self.dlg.detailButton.setEnabled(False)
        self.dlg.resetDatabaseButton.setEnabled(False)
        self.dlg.positionableClass.setEnabled(False)
        self.dlg.attribute.setEnabled(False)
        self.dlg.positionable.setEnabled(False)
        self.dlg.detail.setEnabled(False)

    def set_ui_access_database(self):
        # enable database param
        self.dlg.resetConnectionButton.setEnabled(True)
        self.dlg.database.setEnabled(True)
        self.dlg.database_2.setEnabled(True)
        self.dlg.detailButton.setEnabled(True)
        self.dlg.resetDatabaseButton.setEnabled(True)
        self.dlg.positionableClass.setEnabled(True)
        self.dlg.attribute.setEnabled(True)
        self.dlg.selectAllPositionableClass.setCheckable(True)
        self.dlg.selectAllAttribute.setCheckable(True)
        self.dlg.addLayers.setEnabled(True)
        self.dlg.updateLayers.setEnabled(True)

        # disable all other
        self.dlg.url.setEnabled(False)
        self.dlg.login.setEnabled(False)
        self.dlg.password.setEnabled(False)
        self.dlg.loginButton.setEnabled(False)
        self.dlg.positionable.setEnabled(False)
        self.dlg.detail.setEnabled(False)

    def set_ui_access_detail(self):
        # enable database param
        self.dlg.resetConnectionButton.setEnabled(True)
        self.dlg.resetDatabaseButton.setEnabled(True)
        self.dlg.positionable.setEnabled(True)
        self.dlg.detail.setEnabled(True)
        self.dlg.addLayers.setEnabled(True)
        self.dlg.updateLayers.setEnabled(True)
        # disable all other
        self.dlg.database.setEnabled(False)
        self.dlg.database_2.setEnabled(True)
        self.dlg.detailButton.setEnabled(False)
        self.dlg.positionableClass.setEnabled(False)
        self.dlg.attribute.setEnabled(False)
        self.dlg.url.setEnabled(False)
        self.dlg.login.setEnabled(False)
        self.dlg.password.setEnabled(False)
        self.dlg.loginButton.setEnabled(False)
        self.dlg.selectAllPositionableClass.setCheckable(False)
        self.dlg.selectAllAttribute.setCheckable(True)

    """
    /****************************************************************
    * Method used to build listView object of UI.
    ****************************************************************/  
    """

    def build_list_positionable_class(self):
        model = QStandardItemModel()
        for obj in self.data:
            item = QStandardItem(obj)
            item.setCheckState(Qt.Checked)
            item.setCheckable(True)
            model.appendRow(item)
        model.itemChanged.connect(self.on_positionable_class_list_changed)
        self.dlg.positionableClass.setModel(model)

    def build_list_attribute(self):
        model = QStandardItemModel()
        defaultAttribute = ["_id", "geometry", "@class", "libelle", "designation"]
        for attr in self.data[self.currentPositionableClass]["attributes"]:
            item = QStandardItem(attr)
            if attr in defaultAttribute:
                item.setCheckable(False)
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckable(True)
                if self.data[self.currentPositionableClass]["attributes"][attr]:
                    item.setCheckState(Qt.Checked)
                else:
                    item.setCheckState(Qt.Unchecked)
            model.appendRow(item)
        model.itemChanged.connect(self.on_attribute_list_changed)
        self.dlg.attribute.setModel(model)

    def build_list_positionable(self):
        model = QStandardItemModel()
        for pos in self.positionableSelected:
            name = Utils.build_row_name_positionable(pos)
            item = QStandardItem(name)
            item.setCheckable(True)
            item.setCheckState(Qt.Checked)
            model.appendRow(item)
        model.itemChanged.connect(self.on_positionable_list_changed)
        self.dlg.positionable.setModel(model)

    def change_positionable_class(self, state):
        model = QStandardItemModel()
        for className in self.data:
            self.data[className]["selected"] = state
            item = QStandardItem(className)
            item.setCheckable(True)
            if state:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
            model.appendRow(item)
        model.itemChanged.connect(self.on_positionable_class_list_changed)
        self.dlg.positionableClass.setModel(model)

    def change_positionable(self, state):
        model = QStandardItemModel()
        for className in self.data:
            for id in self.data[className]["ids"]:
                self.data[className]["ids"][id] = state
        for pos in self.positionableSelected:
            name = Utils.build_row_name_positionable(pos)
            item = QStandardItem(name)
            item.setCheckable(True)
            if state:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
            model.appendRow(item)
        model.itemChanged.connect(self.on_positionable_list_changed)
        self.dlg.positionable.setModel(model)

    def change_attribute(self, state):
        model = QStandardItemModel()
        defaultAttribute = ["_id", "geometry", "@class", "libelle", "designation"]
        for attr in self.data[self.currentPositionableClass]["attributes"]:
            item = QStandardItem(attr)
            if attr in defaultAttribute:
                item.setCheckable(False)
                item.setCheckState(Qt.Checked)
                self.data[self.currentPositionableClass]["attributes"][attr] = True
            else:
                item.setCheckable(True)
                self.data[self.currentPositionableClass]["attributes"][attr] = state
                if state:
                    item.setCheckState(Qt.Checked)
                else:
                    item.setCheckState(Qt.Unchecked)
            model.appendRow(item)
        model.itemChanged.connect(self.on_attribute_list_changed)
        self.dlg.attribute.setModel(model)

    """
    /****************************************************************
    * Method used to trigger process after the user performed an
    * action.
    ****************************************************************/  
    """

    def on_login_click(self):
        try:
            http, addr = Utils.parse_url(self.dlg.url.text())
            self.connector = CouchdbConnector(http, addr, self.dlg.login.text(), self.dlg.password.text())
            connection = self.connector.getConnection()
            filtered_connection = []
            for name in connection:
                if not Utils.is_str_start_by_underscore(name):
                    filtered_connection.append(name)
            self.dlg.database.addItems([name for name in filtered_connection])
            self.dlg.database_2.addItems([name for name in filtered_connection])
            self.build_list_positionable_class()
            self.set_ui_access_database()
        except ConnectionRefusedError:
            widget = self.iface.messageBar().createMessage("CouchdbConnectorException",
                                                           "Impossible de se connecter, vérifier l'url ou l'ouverture de la base.")
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=5)
            raise CouchdbConnectorException("Impossible de se connecter à la base")
        except ValueError:
            widget = self.iface.messageBar().createMessage("CouchdbConnectorException",
                                                           "Impossible de se connecter, vérifier l'url ou l'ouverture de la base.")
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=5)
            raise CouchdbConnectorException("Impossible de se connecter à la base")

    def on_detail_click(self):
        self.update_positionable_selected()
        self.complete_data_with_ids()
        self.build_list_positionable()
        self.set_ui_access_detail()

    def on_positionable_class_click(self, item):
        model = self.dlg.positionableClass.model()
        model.blockSignals(True)
        self.currentPositionableClass = model.itemFromIndex(item).text()
        self.build_list_attribute()
        model.blockSignals(False)

    def on_positionable_click(self, item):
        model = self.dlg.positionable.model()
        rowName = model.itemFromIndex(item)
        id = str(rowName.text()).split(' - ')[-1]
        selected = None
        for pos in self.positionableSelected:
            if pos["_id"] == id:
                selected = pos
                break
        if selected is None:
            model.blockSignals(False)
            return
        model = QStandardItemModel()
        listStandardItem = []
        for s in selected:
            self.complete_model_from_positionable(s, selected[s], listStandardItem)
        for row in listStandardItem:
            model.appendRow(row)
        self.dlg.detail.setModel(model)

    def on_select_all_positionable_class_click(self):
        if self.dlg.selectAllPositionableClass.checkState() == Qt.Checked:
            self.change_positionable_class(True)
        if self.dlg.selectAllPositionableClass.checkState() == Qt.Unchecked:
            self.change_positionable_class(False)

    def on_select_all_positionable_click(self):
        if self.dlg.selectAllPositionable.checkState() == Qt.Checked:
            self.change_positionable(True)
        if self.dlg.selectAllPositionable.checkState() == Qt.Unchecked:
            self.change_positionable(False)

    def on_select_all_attribute_click(self):
        if self.dlg.selectAllAttribute.checkState() == Qt.Checked:
            self.change_attribute(True)
        if self.dlg.selectAllAttribute.checkState() == Qt.Unchecked:
            self.change_attribute(False)

    def on_reset_connection_click(self):
        # reset database
        self.on_reset_database_click()
        # reset connection
        self.connector = None
        # reset url, login and password fields
        self.dlg.url.setText("")
        self.dlg.login.setText("")
        self.dlg.password.setText("")
        # reset database combobox
        self.dlg.database.clear()
        self.dlg.database_2.clear()
        # reset positionable class list
        model = self.dlg.positionableClass.model()
        if model:
            model.removeRows(0, model.rowCount())
        # change access
        self.set_ui_access_connection()

    def on_reset_database_click(self):
        # reset list object
        self.positionableSelected = []
        self.complete_data_with_configuration()
        # reset list ui
        modelPositionable = self.dlg.positionable.model()
        if modelPositionable:
            modelPositionable.removeRows(0, modelPositionable.rowCount())
        modelAttribute = self.dlg.attribute.model()
        if modelAttribute:
            modelAttribute.removeRows(0, modelAttribute.rowCount())
        modelDetail = self.dlg.detail.model()
        if modelDetail:
            modelDetail.removeRows(0, modelDetail.rowCount())
        # build list positionable class
        self.build_list_positionable_class()
        # change access
        self.set_ui_access_database()

    def on_attribute_list_changed(self, item):
        attributeSelected = str(item.text())
        if item.checkState() == Qt.Checked:
            state = True
        if item.checkState() == Qt.Unchecked:
            state = False
        self.data[self.currentPositionableClass]["attributes"][attributeSelected] = state

    def on_positionable_list_changed(self, item):
        id = str(item.text()).split(' - ')[-1]
        className = str(item.text()).split(' - ')[0]
        if item.checkState() == Qt.Checked:
            self.data[className]["ids"][id] = True
        if item.checkState() == Qt.Unchecked:
            self.data[className]["ids"][id] = False

    def on_positionable_class_list_changed(self, item):
        if item.checkState() == Qt.Checked:
            self.data[item.text()]["selected"] = True
            self.data[item.text()]["ids"] = "all"
        if item.checkState() == Qt.Unchecked:
            self.data[item.text()]["selected"] = False

    def on_projection_click(self):
        if self.dlg.projete.isChecked():
            self.projection = "projeté"
        if self.dlg.absolu.isChecked():
            self.projection = "absolu"

    def on_update_layers_click(self):

        # recover current layer and check if they exist

        layers = QgsProject.instance().mapLayers()
        if len(layers) == 0:
            widget = self.iface.messageBar().createMessage("Aucune couche trouvée.")
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, 5)
            return

        # retrieves the layers present in the database

        try:
            self.connector = None
            http, addr = Utils.parse_url(self.dlg.url.text())
            self.connector = CouchdbConnector(http, addr, self.dlg.login.text(), self.dlg.password.text())
            format = {}
            for l in layers:
                firstId = self.recover_layer_id((layers[l]))
                if firstId != -1:
                    format[firstId] = layers[l]
            query = Utils.build_query_only_id(format.keys())
            couchdbServer = self.connector.getConnection()
            db = couchdbServer[self.dlg.database_2.currentText()]
            result = db.find(query)
            widget = self.iface.messageBar().createMessage("Toutes les couches sont mis à jour.")
            self.iface.messageBar().pushWidget(widget, Qgis.Info, duration=3)
        except ConnectionRefusedError:
            widget = self.iface.messageBar().createMessage("CouchdbConnectorException",
                                                           "Impossible de se connecter, vérifier l'url ou l'ouverture de la base.")
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=5)
            raise CouchdbConnectorException("Impossible de se connecter à la base")

        # browse the layers and update geometry and attribute table list

        for data in result:
            id = data["_id"]
            classNameComplete = data["@class"]
            className = classNameComplete.split("fr.sirs.core.model.")[1]
            if "libelle" in data.keys():
                label = data["libelle"]
            elif "designation" in data.keys():
                label = data["designation"]
            else:
                label = data["_id"]
            if "geometry" in data.keys():
                geom = data["geometry"]
            else:
                widget = self.iface.messageBar().createMessage("Couche " + id, "Aucune donnée projetée trouvée.")
                self.iface.messageBar().pushWidget(widget, Qgis.Critical, duration=5)
                continue
            formatGeom, geomType = self.format_geometry(geom)
            attrList, attrValueList = self.format_list_attribute(data, className)
            layer = format[id]
            layer.setName(label)
            if layer.wkbType() == 1 and geomType != "POINT" or layer.wkbType() == 2 and geomType != "LINESTRING":
                widget = self.iface.messageBar().createMessage("Couche " + str(layer.id()), "La mise à jour va écraser le style courant de cette donnée, souhaitez-vous effectuer la mise à jour de cette donnée ?")
                self.iface.messageBar().pushWidget(widget, Qgis.Critical)
                layer = self.build_new_layer(data, "projeté")
                if layer is None:
                    continue
            provider = layer.dataProvider()
            it = layer.getFeatures()
            for feat in it:
                provider.deleteFeatures([feat.id()])
            feature = QgsFeature()
            feature.setAttributes(attrValueList)
            feature.setGeometry(formatGeom)
            provider.addFeature(feature)
            layer.updateExtents()
        self.dlg.close()

    def on_add_layers_click(self):
        self.update_positionable_selected()
        self.complete_data_with_ids()
        self.add_layers()
        self.dlg.close()

    """
    /****************************************************************
    * Method used to build the list of detail for a positionable, and
    * build a single line attribute.
    ****************************************************************/  
    """

    def complete_model_from_positionable(self, name, obj, out):
        if type(obj) is str:
            it = QStandardItem(name + " : " + obj)
            out.append(it)
        elif type(obj) is int:
            it = QStandardItem(name + " : " + str(obj))
            out.append(it)
        elif type(obj) is float:
            it = QStandardItem(name + " : " + str(obj))
            out.append(it)
        elif type(obj) is bool:
            it = QStandardItem(name + " : " + str(obj))
            out.append(it)
        elif type(obj) is list:
            for index in range(len(obj)):
                self.complete_model_from_positionable(name + "_" + str(index), obj[index], out)
        elif type(obj) is dict:
            for it in obj:
                self.complete_model_from_positionable(name + "_" + it, obj[it], out)
        else:
            it = QStandardItem(name + " : unknown type")
            out.append(it)

    def format_list_attribute_generic(self, name, obj, attr, value):
        if type(obj) == str:
            attr.append(QgsField(name, QVariant.String))
            value.append(obj)
        elif type(obj) == int:
            attr.append(QgsField(name, QVariant.Int))
            value.append(obj)
        elif type(obj) == float:
            attr.append(QgsField(name, QVariant.Double))
            value.append(obj)
        elif type(obj) == bool:
            attr.append(QgsField(name, QVariant.Bool))
            value.append(obj)
        elif type(obj) == list:
            i = 1
            for it in obj:
                attr2, value2 = self.format_list_attribute_generic(name + "_" + str(i), it, [], [])
                i = i + 1
                for j in range(len(attr2)):
                    attr.append(attr2[j])
                    value.append(value2[j])
        elif type(obj) == dict:
            i = 1
            for it in obj:
                attr2, value2 = self.format_list_attribute_generic(name + "_" + str(it), obj[it], [], [])
                i = i + 1
                for j in range(len(attr2)):
                    attr.append(attr2[j])
                    value.append(value2[j])
        else:
            attr.append(QgsField(name, QVariant.String))
            value.append("NoneType")
        return attr, value

    def format_list_attribute(self, content, className):
        attrList = []
        attrValueList = []
        pref = self.data[className]["attributes"]
        for attr in pref:
            if pref[attr]:
                if attr in content.keys():
                    if type(content[attr]) == str:
                        attrList.append(QgsField(attr, QVariant.String))
                        attrValueList.append(content[attr])
                    elif type(content[attr]) == float:
                        attrList.append(QgsField(attr, QVariant.Double))
                        attrValueList.append(content[attr])
                    elif type(content[attr]) == bool:
                        attrList.append(QgsField(attr, QVariant.Bool))
                        attrValueList.append(content[attr])
                    elif type(content[attr]) == int:
                        attrList.append(QgsField(attr, QVariant.Int))
                        attrValueList.append(content[attr])
                    elif type(content[attr]) == list or type(content[attr]) == dict:
                        attrListRec, attrValueListRec = self.format_list_attribute_generic(attr, content[attr], [], [])
                        for i in range(len(attrListRec)):
                            attrList.append(attrListRec[i])
                            attrValueList.append(attrValueListRec[i])
                    else:
                        attrList.append(QgsField(attr, QVariant.Invalid))
                        attrValueList.append(content[attr])
                else:
                    attrList.append(QgsField(attr, QVariant.String))
                    attrValueList.append("NULL")
        return attrList, attrValueList

    """
    /****************************************************************
    * Method used to build and update layers
    ****************************************************************/  
    """

    def add_layers(self):
        # save the current parameter
        self.write_configuration()

        # build and add new layers if they are not in the layerTreeRoot
        root = QgsProject.instance().layerTreeRoot()
        currentLayer = self.recover_map_layer()
        for pos in self.positionableSelected:
            id = pos["_id"]
            classNameComplete = pos["@class"]
            className = classNameComplete.split("fr.sirs.core.model.")[1]
            if id in currentLayer.keys():
                widget = self.iface.messageBar().createMessage("Couche " + str(id), "La couche est déjà chargée. Clickez sur 'Mise à jour des couches' pour actualiser ses données.")
                self.iface.messageBar().pushWidget(widget, Qgis.Info, 5)
                continue

            # build new layer
            layer = self.build_new_layer(pos, self.projection)
            if layer is None:
                continue

            # sort layers in correspond class
            group = root.findGroup(className)
            if group is None:
                group = root.addGroup(className)
            QgsProject.instance().addMapLayer(layer, False)
            group.addLayer(layer)

    def recover_map_layer(self):
        result = {}
        listCurrentId = Utils.build_list_id_from_data(self.data)
        layers = QgsProject.instance().mapLayers()
        for l in layers:
            id = self.recover_layer_id(layers[l])
            if id != -1:
                if id in listCurrentId:
                    result[id] = layers[l]
        return result

    def recover_layer_id(self, layer):
        if layer.type() != 0:
            return -1
        features = layer.getFeatures()
        for f in features:
            idx = layer.fields().indexFromName("_id")
            if idx != -1:
                return f["_id"]
        return -1

    def recover_layer_field_index(self, layer, className):
        if layer.type() != 0:
            return -1
        for attr in self.data[className]["attributes"].keys():
            if layer.fields().indexFromName(attr) != -1:
                return layer.fields().indexFromName(attr)
        return -1

    def build_wkt(self, data, projectionType):
        if projectionType == "projeté":
            if "geometry" in data.keys():
                return data["geometry"]
            else:
                widget = self.iface.messageBar().createMessage("Couche " + data["_id"], "Aucune donnée projetée trouvée.")
                self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=5)
                return None
        elif projectionType == "absolu":
            if "approximatePositionDebut" in data.keys() and "approximatePositionFin" in data.keys():
                a = data["approximatePositionDebut"]
                b = data["approximatePositionFin"]
                geomA = QgsGeometry.fromWkt(a)
                geomB = QgsGeometry.fromWkt(b)
                return QgsLineString(geomA, geomB).asWkt()
            else:
                widget = self.iface.messageBar().createMessage("Couche " + data["_id"],
                                                               "Aucune position réelle trouvée: Utilisation des données projetées.")
                self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=5)
                if "geometry" in data.keys():
                    return data["geometry"]
                else:
                    widget = self.iface.messageBar().createMessage("Couche " + data["_id"],
                                                                   "Aucune donnée projetée trouvée.")
                    self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=5)
                    return None

    def build_new_layer(self, data, projectionType):
        classNameComplete = data["@class"]
        className = classNameComplete.split("fr.sirs.core.model.")[1]
        if "libelle" in data.keys():
            label = data["libelle"]
        elif "designation" in data.keys():
            label = data["designation"]
        else:
            label = data["_id"]
        geom = self.build_wkt(data, projectionType)
        if geom is None:
            return None
        crs = self.data[className]["crs"]
        formatGeom, geomType = self.format_geometry(geom)
        attrList, attrValueList = self.format_list_attribute(data, className)
        layer = QgsVectorLayer(geomType + "?crs=" + crs, label, "memory")
        if geomType == "POINT":
            props = self.data[className]["style"]["point"]
            symbol = QgsMarkerSymbol.createSimple(props)
        else:
            props = self.data[className]["style"]["default"]
            symbol = QgsLineSymbol.createSimple(props)
            symbol.setOpacity(0.5)
        layer.renderer().setSymbol(symbol)
        provider = layer.dataProvider()
        provider.addAttributes(attrList)
        layer.updateFields()
        feature = QgsFeature()
        feature.setAttributes(attrValueList)
        feature.setGeometry(formatGeom)
        provider.addFeature(feature)
        layer.updateExtents()
        return layer

    def format_geometry(self, wkt):
        geomType = wkt.split(' ')[0]
        geom = QgsGeometry.fromWkt(wkt)
        multi_geom = QgsGeometry()
        temp_geom = []
        if geom.type() == 0:
            return geom, "POINT"
        elif geom.type() == 1:
            if geom.isMultipart():
                multi_geom = geom.asMultiPolyline()
                for i in multi_geom:
                    temp_geom.extend(i)
            else:
                temp_geom = geom.asPolyline()
            if self.is_point(temp_geom):
                # te be more rigorous, I should take the barycenter from the list
                return QgsPoint(temp_geom[0]), "POINT"
            else:
                return geom, geomType
        elif geom.type() == 2:
            # to find the maximum length inside geometry, I apply the convexhull to recover only pertinent point,
            # before apply empirical research
            hull = geom.convexHull()
            if hull.isMultipart():
                multi_geom = hull.asMultiPolygon()
                for i in multi_geom:
                    for j in i:
                        temp_geom.extend(j)
            else:
                multi_geom = hull.asPolygon()
                for i in multi_geom:
                    temp_geom.extend(i)
            if self.is_point(temp_geom):
                # to be more rigorous, I should take the barycenter from the list
                return QgsPoint(temp_geom[0]), "POINT"
            else:
                return geom, geomType
        else:
            widget = self.iface.messageBar().createMessage("Type de geometrie inconnu")
            self.iface.messageBar().pushWidget(widget, Qgis.Warning, duration=5)
            return geom, geomType

    def is_point(self, listPoint):
        for p1 in listPoint:
            for p2 in listPoint:
                if p1.distance(p2) > self.lengthParameter:
                    return False
        return True

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started

        if self.first_start == True:
            self.first_start = False
            self.dlg = CouchdbImporterDialog()
            # load action
            self.dlg.loginButton.clicked.connect(self.on_login_click)
            self.dlg.detailButton.clicked.connect(self.on_detail_click)
            # select all action
            self.dlg.selectAllPositionableClass.stateChanged.connect(self.on_select_all_positionable_class_click)
            self.dlg.selectAllPositionable.stateChanged.connect(self.on_select_all_positionable_click)
            self.dlg.selectAllAttribute.stateChanged.connect(self.on_select_all_attribute_click)
            # reset action
            self.dlg.resetConnectionButton.clicked.connect(self.on_reset_connection_click)
            self.dlg.resetDatabaseButton.clicked.connect(self.on_reset_database_click)
            # detail action
            self.dlg.positionable.clicked.connect(self.on_positionable_click)
            self.dlg.positionableClass.clicked.connect(self.on_positionable_class_click)
            # display action
            self.dlg.absolu.clicked.connect(self.on_projection_click)
            self.dlg.projete.clicked.connect(self.on_projection_click)
            # add / update layers action
            self.dlg.addLayers.clicked.connect(self.on_add_layers_click)
            self.dlg.updateLayers.clicked.connect(self.on_update_layers_click)
            # initialize ui access and data
            self.on_reset_connection_click()
            # default url connection
            self.dlg.url.setText("http://localhost:5984")
            # default choice of projection
            self.dlg.projete.setChecked(True)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            pass
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            # pass
