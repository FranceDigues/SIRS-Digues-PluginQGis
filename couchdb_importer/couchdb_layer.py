# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CouchdbImporter
                                 A QGIS plugin
 This plugin allows importing vector data from the couchdb database.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-01-30
        git sha              : $Format:%H$
        copyright            : (C) 2020 by MaximeGavens/Geomatys
        email                : contact@geomatys.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import json

from qgis.PyQt.QtCore import QVariant
from qgis.PyQt.QtGui import QStandardItem
from qgis.core import QgsFeature, QgsVectorLayer, QgsField, QgsLineSymbol, QgsMarkerSymbol, QgsWkbTypes, QgsFillSymbol

from .couchdb_data import CouchdbData
from .couchdb_connector import CouchdbConnector


class CouchdbBuilder(object):
    def __init__(self):
        self.gender_map = self.init_gender_map()
        __location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))
        with open(os.path.join(__location__, 'formTemplatePilote.json')) as confFile:
            self.configuration = json.load(confFile)

    def build_layer(self, className, geom, data: CouchdbData):
        crs = data.getCrs(className)
        fields = self.build_layer_fields(className)
        layer = QgsVectorLayer(QgsWkbTypes.displayString(geom.wkbType()) + "?crs=" + crs, className, "memory")

        if geom.wkbType() == QgsWkbTypes.Point:
            props = data.getStylePoint(className)
            symbol = QgsMarkerSymbol.createSimple(props)
        elif geom.wkbType() == QgsWkbTypes.LineString:
            props = data.getStyleLine(className)
            symbol = QgsLineSymbol.createSimple(props)
            symbol.setOpacity(0.7)
        elif geom.wkbType() == QgsWkbTypes.Polygon:
            props = data.getStylePolygon(className)
            symbol = QgsFillSymbol.createSimple(props)
            symbol.setOpacity(0.4)
        else:
            print("[UNKNOWN GEOM TYPE]: " + str(geom))
            return None

        layer.renderer().setSymbol(symbol)
        provider = layer.dataProvider()
        provider.addAttributes(fields)
        layer.updateFields()
        return layer

    def build_layer_fields(self, className):
        target = [QgsField("_id (ne pas modifier/supprimer)", QVariant.String), QgsField("@class", QVariant.String)]
        fields = self.configuration[className]

        for attribute in fields:
            conf = fields[attribute]

            name = conf["name"]
            label = conf["label"]
            ttype = conf["type"]
            ref = conf["reference"]

            if ref:
                multiple = conf.get("multiple", 1)
                label_suffix = "actuel"
                if name in self.gender_map:
                    label_suffix = self.gender_map.get(name, "actuel")
                else:
                    print("[KEY NOT FOUND]: no gender for: " + str(name))
                # single reference
                if multiple == 1:
                    if conf.get("containment", False):
                        for cf in self.build_layer_fields(ttype):
                            cf.setName(label + " " + cf.name())
                            target.append(cf)
                    else:
                        if name in ["borneDebutId", "borneFinId", "tronconId"]:
                            target.append(QgsField(label + " libellé", QVariant.String))
                            target.append(QgsField(label + " désignation", QVariant.String))
                        else:
                            target.append(QgsField(label, QVariant.String))
                # multiple references
                elif multiple == -1:
                    # remove the plural mark
                    label = label[:-1] if (len(label) != 0 and label[-1] == "s") else label
                    if conf.get("containment", False):
                        for cf in self.build_layer_fields(ttype):
                            cf.setName(label + " " + cf.name())
                            target.append(cf)
                    else:
                        if name == "prestationIds":
                            for p in self.__treat_prestations():
                                target.append(QgsField(p[0], QVariant.String))
                        else:
                            target.append(QgsField(label + " " + label_suffix, QVariant.String))
            else:
                qgs_field = self.__treat_primitive_type_fields(name, ttype, label)
                if qgs_field is not None:
                    target.append(qgs_field)
        return target

    def build_feature(self, positionable, formatGeom, layer, data: CouchdbData, connector: CouchdbConnector, database):
        attrValue = self.build_field_value(positionable, data, connector, database)

        # complete with class and id
        ID = positionable.get("_id", None)
        if ID is None:
            print("[ERROR DATABASE]: object without _id: " + str(positionable))
            return None
        attrValue["_id (ne pas modifier/supprimer)"] = ID
        attrValue["@class"] = positionable["@class"].split("fr.sirs.core.model.")[1]

        feature = QgsFeature(layer.fields())
        feature.setGeometry(formatGeom)
        for label in attrValue:
            if layer.fields().indexFromName(label) != -1:
                feature.setAttribute(label, attrValue[label])
            else:
                print("[FIELD NOT FOUND]: " + label)
        return feature

    def build_field_value(self, content, data: CouchdbData, connector: CouchdbConnector, database, containment=False):
        values = {}
        className = content["@class"].split("fr.sirs.core.model.")[1]
        pref = data.getAttributes(className, containment)
        fields = self.configuration[className]

        for attr in pref:
            if pref[attr]:
                conf = fields.get(attr, None)
                if conf is None:
                    print("[NOT FOUND IN FIELDS]: class: " + className + "; attribute: " + attr)
                    continue

                val = content.get(attr, None)
                if val is None:
                    continue

                name = conf["name"]
                label = conf["label"]
                ttype = conf["type"]
                ref = conf["reference"]

                if ref:
                    multiple = conf.get("multiple", 1)
                    label_suffix = self.gender_map.get(name, "actuel")
                    # single reference
                    if multiple == 1:
                        if conf.get("containment", False):
                            containment_values = self.build_field_value(val, data, connector, database, True)
                            self.__treat_containment(values, val, containment_values, label)
                        else:
                            if name in ["borneDebutId", "borneFinId", "tronconId"]:
                                values[label + " libellé"] = connector.get_value_or_id_from_id(database, val, 'libelle')
                                values[label + " désignation"] = connector.get_value_or_id_from_id(database, val, 'designation')
                            else:
                                values[label] = connector.get_label_from_id(database, val)
                    # multiple references
                    elif multiple == -1:
                        lenca = len(val)
                        # remove the plural mark
                        label = label[:-1] if (len(label) != 0 and label[-1] == "s") else label
                        if conf.get("containment", False) and lenca >= 1:
                            containment_values = self.build_field_value(val[-1], data, connector, database, True)
                            self.__treat_containment(values, val[-1], containment_values, label)
                        else:
                            if name == "prestationIds":
                                for p in self.__treat_prestations(val, database, connector):
                                    values[p[0]] = p[1]
                            else:
                                if lenca >= 1:
                                    values[label + " " + label_suffix] = connector.get_label_from_id(database, val[-1])
                else:
                    lv = self.__treat_primitive_type_values(conf, val, database, connector)
                    if lv is not None:
                        values[lv[0]] = lv[1]
        return values

    def complete_model_from_positionable(self, obj, database, connector: CouchdbConnector):
        className = obj["@class"].split("fr.sirs.core.model.")[1]
        ID = obj["_id"] if "_id" in obj else obj["id"]
        out = [[QStandardItem("_id"), QStandardItem(ID)], [QStandardItem("@class"), QStandardItem(className)]]
        attributes = self.configuration[className]

        for att in attributes:
            conf = attributes[att]
            name = conf["name"]
            label = conf["label"]
            ttype = conf["type"]
            ref = conf["reference"]
            try:
                val = obj[name]
            except KeyError:
                continue

            if ref:
                multiple = conf.get("multiple", 1)
                label_suffix = self.gender_map.get(name, "actuel")
                # single reference
                if multiple == 1:
                    if name in ["borneDebutId", "borneFinId", "tronconId"]:
                        out.append([QStandardItem(label + " libellé"),
                                    QStandardItem(connector.get_value_or_id_from_id(database, val, 'libelle'))])
                        out.append([QStandardItem(label + " désignation"),
                                    QStandardItem(connector.get_value_or_id_from_id(database, val, 'designation'))])
                    else:
                        out.append([QStandardItem(label), QStandardItem(connector.get_label_from_id(database, val))])
                # multiple references
                elif multiple == -1:
                    lenca = len(val)
                    # remove the plural mark
                    label = label[:-1] if (len(label) != 0 and label[-1] == "s") else label
                    if conf.get("containment", False) and lenca >= 1:
                        out2 = self.complete_model_from_positionable(val[-1], database, connector)
                        for row in out2:
                            row[0].setText(label + " " + row[0].text())
                            out.append(row)
                    else:
                        if name == "prestationIds":
                            for p in self.__treat_prestations(val, database, connector):
                                out.append([QStandardItem(p[0]), QStandardItem(p[1])])
                        else:
                            if lenca >= 1:
                                out.append([QStandardItem(label + " " + label_suffix),
                                            QStandardItem(connector.get_label_from_id(database, val[-1]))])
            else:
                lv = self.__treat_primitive_type_values(name, ttype, label, connector)
                if lv is not None:
                    out.append([QStandardItem(lv[0]), QStandardItem(lv[1])])
        return out

    def __treat_containment(self, values, val, containment_values, label):
        for k in containment_values:
            l = label + " " + k
            values[l] = containment_values[k]
        values[label + " _id (ne pas modifier/supprimer)"] = val[-1]["id"]
        values[label + " @class"] = val[-1]["@class"].split("fr.sirs.core.model.")[1]

    def __treat_prestations(self, val=(), database=None, connector: CouchdbConnector=None):
        l = len(val)
        yield ("Prestation actuelle libellé", connector.get_value_or_id_from_id(database, val[-1],
                                                                                            'libelle') if l >= 1 else "Aucune donnée")
        yield ("Prestation actuelle désignation", connector.get_value_or_id_from_id(database, val[-1],
                                                                                                'designation') if l >= 1 else "Aucune donnée")
        yield("Avant dernière Prestation libellé", connector.get_value_or_id_from_id(database, val[-2],
                                                                                                  'libelle') if l >= 2 else "Aucune donnée")
        yield("Avant dernière Prestation désignation", connector.get_value_or_id_from_id(database, val[-2],
                                                                                                      'designation') if l >= 2 else "Aucune donnée")
        yield("Prestation N-3 libellé", connector.get_value_or_id_from_id(database, val[-3],
                                                                                       'libelle') if l >= 3 else "Aucune donnée")
        yield("Prestation N-3 désignation", connector.get_value_or_id_from_id(database, val[-3],
                                                                                           'designation') if l >= 3 else "Aucune donnée")

    def __treat_primitive_type_fields(self, name, ttype, label):
        if name == "borne_debut_aval":
            return QgsField("Borne de début: Amont/Aval", QVariant.String)
        elif name == "borne_fin_aval":
            return QgsField("Borne de fin: Amont/Aval", QVariant.String)
        elif ttype in ["EString", "EDate", "Point", "Geometry"]:
            return QgsField(label, QVariant.String)
        elif ttype == "EInt":
            return QgsField(label, QVariant.Int)
        elif ttype == "EBoolean" or ttype == "EBooleanObject":
            return QgsField(label, QVariant.Bool)
        elif ttype == "EFloat" or ttype == "EDouble":
            return QgsField(label, QVariant.Double)
        else:
            print("[TYPE NOT FOUND]: " + ttype)
            return None

    def __treat_primitive_type_values(self, conf, val, database, connector: CouchdbConnector):
        name = conf["name"]
        label = conf["label"]
        ttype = conf["type"]

        if name == "author":
            return label, connector.get_value_or_id_from_id(database, val, "login")
        elif name == "borne_debut_aval":
            return "Borne de début: Amont/Aval", "Amont" if val else "Aval"
        elif name == "borne_fin_aval":
            return "Borne de fin: Amont/Aval", "Amont" if val else "Aval"
        elif ttype in ["EString", "EDate", "EInt", "EBoolean", "EFloat", "EDouble", "Point", "Geometry", "EBooleanObject"]:
            return label, val
        else:
            print("[UNEXPECTED BEHAVIOUR]: Unknow conf type: " + str(ttype))
            return None

    def init_gender_map(self):
        fem = [
            "digueIds",
            "digueId",
            "bergeIds",
            "bergeId",
            "crueSubmersionIds",
            "echelleLimnimetriqueIds",
            "ouvertureBatardableIds",
            "planifications",
            "voieDigueIds",
            "voieAccesIds",
            "borneIds",
            "stationPompageIds",
            "photos",
            "observations",
            "proprietes",
            "mesuresDZ",
            "mesures",
            "gestions",
            "prestationIds",
            "structureIds",
            "borneDebutId",
            "borneFinId",
            "coteId",
            "positionId",
            "sourceId",
            "categorieDesordreId",
            "orientationPhoto",
            "urgenceId",
            "destinationId",
            "fonctionId",
            "natureId",
            "dependanceId",
            "referenceHauteurId",
            "positionHautId",
            "positionBasId",
            "orientationOuvrageId",
            "globalPrestationIds",
            "origineProfilLongId",
            "positionProfilLongSurDigueId",
            "fonctionBasId",
            "fonctionHautId",
            "natureBasId",
            "natureHautId",
            "implantationId",
            "utilisationConduiteId",
            "fosse",
            "mesuresXYZ",
            "pompes",
            "parcelleId",
            "hauteurId"
        ]
        mas = [
            "intervenantsIds",
            "reseauTelecomEnergieIds",
            "reseauHydrauliqueCielOuvertIds",
            "articleIds",
            "ouvrageTelecomEnergieIds",
            "ouvrageFranchissementIds",
            "ouvrageRevancheIds",
            "ouvrageHydrauliqueAssocieIds",
            "ouvrageVoirieIds",
            "ouvrageParticulierIds",
            "levePositionIds",
            "desordreIds",
            "reseauHydrauliqueFermeIds",
            "evenementHydrauliqueIds",
            "seuilIds",
            "rapportEtudeIds",
            "pointsLeveDZ",
            "systemeRepId",
            "linearId",
            "typeDesordreId",
            "observateurId",
            "photographeId",
            "amenagementHydrauliqueId",
            "typeRiveId",
            "typeTronconId",
            "systemeRepDefautId",
            "organismeId",
            "typeId",
            "etatId",
            "contactId",
            "materiauId",
            "ouvrageAssocieIds",
            "gestionnaireIds",
            "fonctionnementId",
            "tronconIds",
            "proprietaireIds",
            "typePrestationId",
            "marcheId",
            "ouvrageAssocieAmenagementHydrauliqueIds",
            "intervenantIds",
            "materiaux",
            "typeMateriauId",
            "amenagementHydrauliqueAssocieIds",
            "desordreDependanceAssocieIds",
            "revetementId",
            "gardes",
            "evenementHydrauliqueId",
            "typeLargeurFrancBord",
            "revetementHautId",
            "revetementBasId",
            "typeOuvrageFranchissementId",
            "usageId",
            "typeOuvrageHydroAssocieId",
            "typeOuvrageParticulierId",
            "typeOuvrageTelecomEnergieId",
            "typeOuvrageVoirieId",
            "sirsdocument",
            "documentGrandeEchelleIds",
            "rapportEtudeId",
            "organismeCreateurId",
            "typeSystemesReleveId",
            "pointsLeveXYZ",
            "systemeRepDzId",
            "typeVoieDigueId",
            "materiauBasId",
            "materiauHautId",
            "parametresHydrauliques",
            "typeProprietaireId",
            "ecoulementId",
            "typeConduiteFermeeId",
            "typeReseauTelecomEnergieId",
            "raccordementId",
            "fusible",
            "seuil",
            "typeReseauHydroCielOuvertId",
            "traitement",
            "typePositionId",
            "typeCoteId",
            "diametreId"
        ]
        gmap = {}
        for f in fem:
            gmap[f] = "actuelle"
        for m in mas:
            gmap[m] = "actuel"
        return gmap

    def get_label_from_attribute(self, className, attribute):
        try:
            return self.configuration[className][attribute]["label"]
        except KeyError:
            return attribute
