# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CouchdbImporter
                                 A QGIS plugin
 This plugin allows importing vector data from the couchdb database.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-01-30
        git sha              : $Format:%H$
        copyright            : (C) 2020 by MaximeGavens/Geomatys
        email                : contact@geomatys.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import json

POSITIONABLES = ["AireStockageDependance", "AmenagementHydraulique", "ArbreVegetation", "AutreDependance",
                 "AutreOuvrageLit", "Berge", "BorneDigue", "CheminAccesDependance", "Crete", "CreteBerge",
                 "Desordre", "DesordreDependance", "DesordreLit", "Deversoir", "DomanialiteLit",
                 "EchelleLimnimetrique", "Epi", "EpiBerge", "Fondation", "FondationBerge", "GardeTroncon",
                 "HerbaceeVegetation", "IleBancLit", "InvasiveVegetation", "LaisseCrue", "LargeurFrancBord",
                 "LargeurLit", "LigneEau", "MonteeEaux", "OccupationRiveraineLit", "OrganeProtectionCollective",
                 "OuvertureBatardable", "OuvrageAssocieAmenagementHydraulique", "OuvrageAssocieLit",
                 "OuvrageFranchissement", "OuvrageHydrauliqueAssocie", "OuvrageParticulier", "OuvrageRevanche",
                 "OuvrageRevancheBerge", "OuvrageTelecomEnergie", "OuvrageVoirie", "OuvrageVoirieDependance",
                 "ParcelleVegetation", "PenteLit", "PeuplementVegetation", "Photo", "PiedBerge", "PiedDigue",
                 "PlageDepotLit", "PositionConvention", "PositionDocument", "PositionProfilTravers", "Prestation",
                 "PrestationAmenagementHydraulique", "ProfilLong", "ProprieteTroncon", "RegimeEcoulementLit",
                 "ReseauHydrauliqueCielOuvert", "ReseauHydrauliqueFerme", "ReseauTelecomEnergie", "SeuilLit",
                 "SommetBerge", "SommetRisberme", "StationPompage", "StructureAmenagementHydraulique", "TalusBerge",
                 "TalusDigue", "TalusRisberme", "TalusRisbermeBerge", "TraitAmenagementHydraulique", "TraitBerge",
                 "TronconDigue", "TronconLit", "VoieAcces", "VoieDigue", "ZoneAtterrissementLit"]

CONTAINMENT_CLASSES = ["Seuil", "Pompe", "MateriauDependance", "CoucheSeuilLit", "TraitementZoneVegetation",
                       "GardeObjet", "ObservationVoieDigue", "ObservationOuvrageVoirie",
                       "ObservationReseauTelecomEnergie", "InspectionSeuilLit", "PrZProfilLong", "OuvrageFreineurLit",
                       "ObservationStationPompage", "XYZProfilLong", "AutreOuvrageRegulationLit", "BarrageLit",
                       "ObservationDependance", "ParametreHydrauliqueProfilLong", "GestionTroncon",
                       "ObservationOuvertureBatardable", "Observation", "MesureMonteeEaux",
                       "ObservationEchelleLimnimetrique", "ObservationOuvrageHydrauliqueAssocie",
                       "ObservationReseauHydrauliqueFerme", "ObservationVoieAcces", "DispositifFusible",
                       "ObservationReseauHydrauliqueCielOuvert", "ProprieteObjet", "GestionObjet", "PlanSeuilLit",
                       "FosseDissipation", "ObservationPrestation", "MesureLigneEauXYZ",
                       "ObservationOuvrageParticulier", "MesureLigneEauPrZ", "ObservationOuvrageFranchissement",
                       "TraitementParcelleVegetation", "PhotoDependance", "ObservationOuvrageTelecomEnergie", "Photo"]


class CouchdbData(object):
    def __init__(self):
        self.positionable = {}
        self.containment = {}
        __location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))
        with open(os.path.join(__location__, "user_preference_correspondence.json")) as inFile:
            preference = json.load(inFile)
            for className in POSITIONABLES:
                self.positionable[className] = {
                    "selected": False,
                    "ids": {},
                    "attributes": preference[className]["attributes"],
                    "style": preference[className]["style"],
                    "crs": preference[className]["crs"]
                }
            for className in CONTAINMENT_CLASSES:
                self.containment[className] = {
                    "selected": False,
                    "ids": {},
                    "attributes": preference[className]["attributes"],
                    "style": preference[className]["style"],
                    "crs": preference[className]["crs"]
                }

    def getPositionable(self):
        return self.positionable

    def getPositionableClass(self, name):
        return self.positionable[name]

    def getClassName(self):
        return self.positionable.keys()

    def getSelected(self, name):
        return self.positionable[name]["selected"]

    def getSelectedCount(self):
        count = 0

        for name in self.positionable:
            count += self.positionable[name]["selected"]
        return count

    def getIds(self, name):
        return self.positionable[name]["ids"]

    def getListId(self, name):
        if type(self.positionable[name]["ids"]) == str:
            return None
        return self.positionable[name]["ids"].keys()

    def getAllId(self):
        result = []
        for className in self.getClassName():
            if type(self.getIds(className)) == str:
                return None
            result.extend(self.positionable[className]["ids"].keys())
        return result

    def getAllIdSelected(self):
        result = []
        for className in self.getClassName():
            for id in self.positionable[className]["ids"]:
                if self.positionable[className]["ids"][id]:
                    result.append(id)
        return result

    def getAttributeSelected(self, className):
        attributes = []
        ca = self.positionable[className]["attributes"]
        for a in ca:
            if ca[a]:
                attributes.append(a)
        return attributes

    def getAttributes(self, className, fromContainment=False):
        try:
            if fromContainment:
                return self.containment[className]["attributes"]
            else:
                return self.positionable[className]["attributes"]
        except KeyError:
            print("[UNKNOWN CLASS]: class not found in preference files: " + className)
            return {}

    def isAttributeSelected(self, className, attribute):
        return self.positionable[className]["attributes"][attribute]

    def getStylePoint(self, name):
        return self.positionable[name]["style"]["point"]

    def getStyleLine(self, name):
        return self.positionable[name]["style"]["line"]

    def getStylePolygon(self, name):
        return self.positionable[name]["style"]["polygon"]

    def getCrs(self, name):
        return self.positionable[name]["crs"]

    def getIdValue(self, name, id):
        return self.positionable[name]["ids"][id]

    def setSelected(self, name, isSelected):
        self.positionable[name]["selected"] = isSelected

    def setIds(self, name, ids):
        self.positionable[name]["ids"] = ids

    def setAttributes(self, name, attributes):
        self.positionable[name]["attributes"] = attributes

    def setStyle(self, name, style):
        self.positionable[name]["style"] = style

    def setCrs(self, name, crs):
        self.positionable[name]["crs"] = crs

    def setAttributeValue(self, name, attribute, value):
        self.positionable[name]["attributes"][attribute] = value

    def setIdValue(self, name, id, isSelected):
        self.positionable[name]["ids"][id] = isSelected

    def write_configuration(self):
        __location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))
        with open(os.path.join(__location__, "user_preference_correspondence.json"), "w") as outFile:
            configuration = {}
            for className in self.positionable:
                configuration[className] = {}
                configuration[className]["attributes"] = self.positionable[className]["attributes"]
                configuration[className]["style"] = self.positionable[className]["style"]
                configuration[className]["crs"] = self.positionable[className]["crs"]
            for className in self.containment:
                configuration[className] = {}
                configuration[className]["attributes"] = self.containment[className]["attributes"]
                configuration[className]["style"] = self.containment[className]["style"]
                configuration[className]["crs"] = self.containment[className]["crs"]
            json.dump(configuration, outFile, indent=2)
